Help on package setuptools:

NAME
    setuptools - Extensions to the 'distutils' for large or complex distributions

PACKAGE CONTENTS
    _deprecation_warning
    _vendor (package)
    archive_util
    build_meta
    command (package)
    config
    dep_util
    depends
    dist
    extension
    extern (package)
    glibc
    glob
    launch
    lib2to3_ex
    monkey
    msvc
    namespaces
    package_index
    pep425tags
    py27compat
    py31compat
    py33compat
    sandbox
    site-patch
    ssl_support
    unicode_utils
    version
    wheel
    windows_support

CLASSES
    builtins.Warning(builtins.Exception)
        setuptools._deprecation_warning.SetuptoolsDeprecationWarning
    builtins.object
        builtins.type
        setuptools.depends.Require
        setuptools.dist.Feature
    distutils.cmd.Command(builtins.object)
        Command
    distutils.dist.Distribution(builtins.object)
        setuptools.dist.Distribution
    distutils.extension.Extension(builtins.object)
        setuptools.extension.Extension
    
    class Command(distutils.cmd.Command)
     |  Command(dist, **kw)
     |  
     |  Abstract base class for defining command classes, the "worker bees"
     |  of the Distutils.  A useful analogy for command classes is to think of
     |  them as subroutines with local variables called "options".  The options
     |  are "declared" in 'initialize_options()' and "defined" (given their
     |  final values, aka "finalized") in 'finalize_options()', both of which
     |  must be defined by every command class.  The distinction between the
     |  two is necessary because option values might come from the outside
     |  world (command line, config file, ...), and any options dependent on
     |  other options must be computed *after* these outside influences have
     |  been processed -- hence 'finalize_options()'.  The "body" of the
     |  subroutine, where it does all its work based on the values of its
     |  options, is the 'run()' method, which must also be implemented by every
     |  command class.
     |  
     |  Method resolution order:
     |      Command
     |      distutils.cmd.Command
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, dist, **kw)
     |      Construct the command for dist, updating
     |      vars(self) with any keyword parameters.
     |  
     |  ensure_string_list(self, option)
     |      Ensure that 'option' is a list of strings.  If 'option' is
     |      currently a string, we split it either on /,\s*/ or /\s+/, so
     |      "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
     |      ["foo", "bar", "baz"].
     |  
     |  reinitialize_command(self, command, reinit_subcommands=0, **kw)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  command_consumes_arguments = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.cmd.Command:
     |  
     |  __getattr__(self, attr)
     |      # XXX A more explicit way to customize dry_run would be better.
     |  
     |  announce(self, msg, level=1)
     |      If the current verbosity level is of greater than or equal to
     |      'level' print 'msg' to stdout.
     |  
     |  copy_file(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)
     |      Copy a file respecting verbose, dry-run and force flags.  (The
     |      former two default to whatever is in the Distribution object, and
     |      the latter defaults to false for commands that don't define it.)
     |  
     |  copy_tree(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)
     |      Copy an entire directory tree respecting verbose, dry-run,
     |      and force flags.
     |  
     |  debug_print(self, msg)
     |      Print 'msg' to stdout if the global DEBUG (taken from the
     |      DISTUTILS_DEBUG environment variable) flag is true.
     |  
     |  dump_options(self, header=None, indent='')
     |  
     |  ensure_dirname(self, option)
     |  
     |  ensure_filename(self, option)
     |      Ensure that 'option' is the name of an existing file.
     |  
     |  ensure_finalized(self)
     |  
     |  ensure_string(self, option, default=None)
     |      Ensure that 'option' is a string; if not defined, set it to
     |      'default'.
     |  
     |  execute(self, func, args, msg=None, level=1)
     |  
     |  finalize_options(self)
     |      Set final values for all the options that this command supports.
     |      This is always called as late as possible, ie.  after any option
     |      assignments from the command-line or from other commands have been
     |      done.  Thus, this is the place to code option dependencies: if
     |      'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
     |      long as 'foo' still has the same value it was assigned in
     |      'initialize_options()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  get_command_name(self)
     |  
     |  get_finalized_command(self, command, create=1)
     |      Wrapper around Distribution's 'get_command_obj()' method: find
     |      (create if necessary and 'create' is true) the command object for
     |      'command', call its 'ensure_finalized()' method, and return the
     |      finalized command object.
     |  
     |  get_sub_commands(self)
     |      Determine the sub-commands that are relevant in the current
     |      distribution (ie., that need to be run).  This is based on the
     |      'sub_commands' class attribute: each tuple in that list may include
     |      a method that we call to determine if the subcommand needs to be
     |      run for the current distribution.  Return a list of command names.
     |  
     |  initialize_options(self)
     |      Set default values for all the options that this command
     |      supports.  Note that these defaults may be overridden by other
     |      commands, by the setup script, by config files, or by the
     |      command-line.  Thus, this is not the place to code dependencies
     |      between options; generally, 'initialize_options()' implementations
     |      are just a bunch of "self.foo = None" assignments.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  make_archive(self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None)
     |  
     |  make_file(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)
     |      Special case of 'execute()' for operations that process one or
     |      more input files and generate one output file.  Works just like
     |      'execute()', except the operation is skipped and a different
     |      message printed if 'outfile' already exists and is newer than all
     |      files listed in 'infiles'.  If the command defined 'self.force',
     |      and it is true, then the command is unconditionally run -- does no
     |      timestamp checks.
     |  
     |  mkpath(self, name, mode=511)
     |  
     |  move_file(self, src, dst, level=1)
     |      Move a file respecting dry-run flag.
     |  
     |  run(self)
     |      A command's raison d'etre: carry out the action it exists to
     |      perform, controlled by the options initialized in
     |      'initialize_options()', customized by other commands, the setup
     |      script, the command-line, and config files, and finalized in
     |      'finalize_options()'.  All terminal output and filesystem
     |      interaction should be done by 'run()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  run_command(self, command)
     |      Run some other command: uses the 'run_command()' method of
     |      Distribution, which creates and finalizes the command object if
     |      necessary and then invokes its 'run()' method.
     |  
     |  set_undefined_options(self, src_cmd, *option_pairs)
     |      Set the values of any "undefined" options from corresponding
     |      option values in some other command object.  "Undefined" here means
     |      "is None", which is the convention used to indicate that an option
     |      has not been changed between 'initialize_options()' and
     |      'finalize_options()'.  Usually called from 'finalize_options()' for
     |      options that depend on some other command rather than another
     |      option of the same command.  'src_cmd' is the other command from
     |      which option values will be taken (a command object will be created
     |      for it if necessary); the remaining arguments are
     |      '(src_option,dst_option)' tuples which mean "take the value of
     |      'src_option' in the 'src_cmd' command object, and copy it to
     |      'dst_option' in the current command object".
     |  
     |  spawn(self, cmd, search_path=1, level=1)
     |      Spawn an external command respecting dry-run flag.
     |  
     |  warn(self, msg)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.cmd.Command:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from distutils.cmd.Command:
     |  
     |  sub_commands = []
    
    class Distribution(distutils.dist.Distribution)
     |  Distribution(attrs=None)
     |  
     |  Distribution with support for features, tests, and package data
     |  
     |  This is an enhanced version of 'distutils.dist.Distribution' that
     |  effectively adds the following new optional keyword arguments to 'setup()':
     |  
     |   'install_requires' -- a string or sequence of strings specifying project
     |      versions that the distribution requires when installed, in the format
     |      used by 'pkg_resources.require()'.  They will be installed
     |      automatically when the package is installed.  If you wish to use
     |      packages that are not available in PyPI, or want to give your users an
     |      alternate download location, you can add a 'find_links' option to the
     |      '[easy_install]' section of your project's 'setup.cfg' file, and then
     |      setuptools will scan the listed web pages for links that satisfy the
     |      requirements.
     |  
     |   'extras_require' -- a dictionary mapping names of optional "extras" to the
     |      additional requirement(s) that using those extras incurs. For example,
     |      this::
     |  
     |          extras_require = dict(reST = ["docutils>=0.3", "reSTedit"])
     |  
     |      indicates that the distribution can optionally provide an extra
     |      capability called "reST", but it can only be used if docutils and
     |      reSTedit are installed.  If the user installs your package using
     |      EasyInstall and requests one of your extras, the corresponding
     |      additional requirements will be installed if needed.
     |  
     |   'features' **deprecated** -- a dictionary mapping option names to
     |      'setuptools.Feature'
     |      objects.  Features are a portion of the distribution that can be
     |      included or excluded based on user options, inter-feature dependencies,
     |      and availability on the current system.  Excluded features are omitted
     |      from all setup commands, including source and binary distributions, so
     |      you can create multiple distributions from the same source tree.
     |      Feature names should be valid Python identifiers, except that they may
     |      contain the '-' (minus) sign.  Features can be included or excluded
     |      via the command line options '--with-X' and '--without-X', where 'X' is
     |      the name of the feature.  Whether a feature is included by default, and
     |      whether you are allowed to control this from the command line, is
     |      determined by the Feature object.  See the 'Feature' class for more
     |      information.
     |  
     |   'test_suite' -- the name of a test suite to run for the 'test' command.
     |      If the user runs 'python setup.py test', the package will be installed,
     |      and the named test suite will be run.  The format is the same as
     |      would be used on a 'unittest.py' command line.  That is, it is the
     |      dotted name of an object to import and call to generate a test suite.
     |  
     |   'package_data' -- a dictionary mapping package names to lists of filenames
     |      or globs to use to find data files contained in the named packages.
     |      If the dictionary has filenames or globs listed under '""' (the empty
     |      string), those names will be searched for in every package, in addition
     |      to any names for the specific package.  Data files found using these
     |      names/globs will be installed along with the package, in the same
     |      location as the package.  Note that globs are allowed to reference
     |      the contents of non-package subdirectories, as long as you use '/' as
     |      a path separator.  (Globs are automatically converted to
     |      platform-specific paths at runtime.)
     |  
     |  In addition to these new keywords, this class also has several new methods
     |  for manipulating the distribution's contents.  For example, the 'include()'
     |  and 'exclude()' methods can be thought of as in-place add and subtract
     |  commands that add or remove packages, modules, extensions, and so on from
     |  the distribution.  They are used by the feature subsystem to configure the
     |  distribution for the included and excluded features.
     |  
     |  Method resolution order:
     |      Distribution
     |      distutils.dist.Distribution
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, attrs=None)
     |      Construct a new Distribution instance: initialize all the
     |      attributes of a Distribution, and then use 'attrs' (a dictionary
     |      mapping attribute names to values) to assign some of those
     |      attributes their "real" values.  (Any attributes not mentioned in
     |      'attrs' will be assigned to some null value: 0, None, an empty list
     |      or dictionary, etc.)  Most importantly, initialize the
     |      'command_obj' attribute to the empty dictionary; this will be
     |      filled in with real command objects by 'parse_command_line()'.
     |  
     |  exclude(self, **attrs)
     |      Remove items from distribution that are named in keyword arguments
     |      
     |      For example, 'dist.exclude(py_modules=["x"])' would remove 'x' from
     |      the distribution's 'py_modules' attribute.  Excluding packages uses
     |      the 'exclude_package()' method, so all of the package's contained
     |      packages, modules, and extensions are also excluded.
     |      
     |      Currently, this method only supports exclusion from attributes that are
     |      lists or tuples.  If you need to add support for excluding from other
     |      attributes in this or a subclass, you can add an '_exclude_X' method,
     |      where 'X' is the name of the attribute.  The method will be called with
     |      the value passed to 'exclude()'.  So, 'dist.exclude(foo={"bar":"baz"})'
     |      will try to call 'dist._exclude_foo({"bar":"baz"})', which can then
     |      handle whatever special exclusion logic is needed.
     |  
     |  exclude_package(self, package)
     |      Remove packages, modules, and extensions in named package
     |  
     |  feature_is_included(self, name)
     |      Return 1 if feature is included, 0 if excluded, 'None' if unknown
     |  
     |  fetch_build_egg(self, req)
     |      Fetch an egg needed for building
     |  
     |  fetch_build_eggs(self, requires)
     |      Resolve pre-setup requirements
     |  
     |  finalize_options(self)
     |      Set final values for all the options on the Distribution
     |      instance, analogous to the .finalize_options() method of Command
     |      objects.
     |  
     |  get_cmdline_options(self)
     |      Return a '{cmd: {opt:val}}' map of all command-line options
     |      
     |      Option names are all long, but do not include the leading '--', and
     |      contain dashes rather than underscores.  If the option doesn't take
     |      an argument (e.g. '--quiet'), the 'val' is 'None'.
     |      
     |      Note that options provided by config files are intentionally excluded.
     |  
     |  get_command_class(self, command)
     |      Pluggable version of get_command_class()
     |  
     |  get_command_list(self)
     |      Get a list of (command, description) tuples.
     |      The list is divided into "standard commands" (listed in
     |      distutils.command.__all__) and "extra commands" (mentioned in
     |      self.cmdclass, but not a standard command).  The descriptions come
     |      from the command class attribute 'description'.
     |  
     |  get_egg_cache_dir(self)
     |  
     |  handle_display_options(self, option_order)
     |      If there were any non-global "display-only" options
     |      (--help-commands or the metadata display options) on the command
     |      line, display the requested info and return true; else return
     |      false.
     |  
     |  has_contents_for(self, package)
     |      Return true if 'exclude_package(package)' would do something
     |  
     |  include(self, **attrs)
     |      Add items to distribution that are named in keyword arguments
     |      
     |      For example, 'dist.exclude(py_modules=["x"])' would add 'x' to
     |      the distribution's 'py_modules' attribute, if it was not already
     |      there.
     |      
     |      Currently, this method only supports inclusion for attributes that are
     |      lists or tuples.  If you need to add support for adding to other
     |      attributes in this or a subclass, you can add an '_include_X' method,
     |      where 'X' is the name of the attribute.  The method will be called with
     |      the value passed to 'include()'.  So, 'dist.include(foo={"bar":"baz"})'
     |      will try to call 'dist._include_foo({"bar":"baz"})', which can then
     |      handle whatever special inclusion logic is needed.
     |  
     |  include_feature(self, name)
     |      Request inclusion of feature named 'name'
     |  
     |  iter_distribution_names(self)
     |      Yield all packages, modules, and extension names in distribution
     |  
     |  parse_command_line(self)
     |      Process features after parsing command line options
     |  
     |  parse_config_files(self, filenames=None, ignore_option_errors=False)
     |      Parses configuration files from various levels
     |      and loads configuration.
     |  
     |  patch_missing_pkg_info(self, attrs)
     |  
     |  print_commands(self)
     |      Print out a help message listing all available commands with a
     |      description of each.  The list is divided into "standard commands"
     |      (listed in distutils.command.__all__) and "extra commands"
     |      (mentioned in self.cmdclass, but not a standard command).  The
     |      descriptions come from the command class attribute
     |      'description'.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.dist.Distribution:
     |  
     |  announce(self, msg, level=2)
     |  
     |  dump_option_dicts(self, header=None, commands=None, indent='')
     |  
     |  find_config_files(self)
     |      Find as many configuration files as should be processed for this
     |      platform, and return a list of filenames in the order in which they
     |      should be parsed.  The filenames returned are guaranteed to exist
     |      (modulo nasty race conditions).
     |      
     |      There are three possible config files: distutils.cfg in the
     |      Distutils installation directory (ie. where the top-level
     |      Distutils __inst__.py file lives), a file in the user's home
     |      directory named .pydistutils.cfg on Unix and pydistutils.cfg
     |      on Windows/Mac; and setup.cfg in the current directory.
     |      
     |      The file in the user's home directory can be disabled with the
     |      --no-user-cfg option.
     |  
     |  get_command_obj(self, command, create=1)
     |      Return the command object for 'command'.  Normally this object
     |      is cached on a previous call to 'get_command_obj()'; if no command
     |      object for 'command' is in the cache, then we either create and
     |      return it (if 'create' is true) or return None.
     |  
     |  get_command_packages(self)
     |      Return a list of packages from which commands are loaded.
     |  
     |  get_option_dict(self, command)
     |      Get the option dictionary for a given command.  If that
     |      command's option dictionary hasn't been created yet, then create it
     |      and return the new dictionary; otherwise, return the existing
     |      option dictionary.
     |  
     |  has_c_libraries(self)
     |  
     |  has_data_files(self)
     |  
     |  has_ext_modules(self)
     |  
     |  has_headers(self)
     |  
     |  has_modules(self)
     |  
     |  has_pure_modules(self)
     |  
     |  has_scripts(self)
     |  
     |  is_pure(self)
     |  
     |  print_command_list(self, commands, header, max_length)
     |      Print a subset of the list of all commands -- used by
     |      'print_commands()'.
     |  
     |  reinitialize_command(self, command, reinit_subcommands=0)
     |      Reinitializes a command to the state it was in when first
     |      returned by 'get_command_obj()': ie., initialized but not yet
     |      finalized.  This provides the opportunity to sneak option
     |      values in programmatically, overriding or supplementing
     |      user-supplied values from the config files and command line.
     |      You'll have to re-finalize the command object (by calling
     |      'finalize_options()' or 'ensure_finalized()') before using it for
     |      real.
     |      
     |      'command' should be a command name (string) or command object.  If
     |      'reinit_subcommands' is true, also reinitializes the command's
     |      sub-commands, as declared by the 'sub_commands' class attribute (if
     |      it has one).  See the "install" command for an example.  Only
     |      reinitializes the sub-commands that actually matter, ie. those
     |      whose test predicates return true.
     |      
     |      Returns the reinitialized command object.
     |  
     |  run_command(self, command)
     |      Do whatever it takes to run a command (including nothing at all,
     |      if the command has already been run).  Specifically: if we have
     |      already created and run the command named by 'command', return
     |      silently without doing anything.  If the command named by 'command'
     |      doesn't even have a command object yet, create one.  Then invoke
     |      'run()' on that command object (or an existing one).
     |  
     |  run_commands(self)
     |      Run each command that was seen on the setup script command line.
     |      Uses the list of commands found and cache of command objects
     |      created by 'get_command_obj()'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.dist.Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from distutils.dist.Distribution:
     |  
     |  common_usage = "Common commands: (see '--help-commands' for more...'\n...
     |  
     |  display_option_names = ['help_commands', 'name', 'version', 'fullname'...
     |  
     |  display_options = [('help-commands', None, 'list all available command...
     |  
     |  global_options = [('verbose', 'v', 'run verbosely (default)', 1), ('qu...
     |  
     |  negative_opt = {'quiet': 'verbose'}
    
    class Extension(distutils.extension.Extension)
     |  Extension(name, sources, *args, **kw)
     |  
     |  Extension that uses '.c' files in place of '.pyx' files
     |  
     |  Method resolution order:
     |      Extension
     |      distutils.extension.Extension
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, sources, *args, **kw)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.extension.Extension:
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.extension.Extension:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Feature(builtins.object)
     |  Feature(description, standard=False, available=True, optional=True, require_features=(), remove=(), **extras)
     |  
     |  **deprecated** -- The `Feature` facility was never completely implemented
     |  or supported, `has reported issues
     |  <https://github.com/pypa/setuptools/issues/58>`_ and will be removed in
     |  a future version.
     |  
     |  A subset of the distribution that can be excluded if unneeded/wanted
     |  
     |  Features are created using these keyword arguments:
     |  
     |    'description' -- a short, human readable description of the feature, to
     |       be used in error messages, and option help messages.
     |  
     |    'standard' -- if true, the feature is included by default if it is
     |       available on the current system.  Otherwise, the feature is only
     |       included if requested via a command line '--with-X' option, or if
     |       another included feature requires it.  The default setting is 'False'.
     |  
     |    'available' -- if true, the feature is available for installation on the
     |       current system.  The default setting is 'True'.
     |  
     |    'optional' -- if true, the feature's inclusion can be controlled from the
     |       command line, using the '--with-X' or '--without-X' options.  If
     |       false, the feature's inclusion status is determined automatically,
     |       based on 'availabile', 'standard', and whether any other feature
     |       requires it.  The default setting is 'True'.
     |  
     |    'require_features' -- a string or sequence of strings naming features
     |       that should also be included if this feature is included.  Defaults to
     |       empty list.  May also contain 'Require' objects that should be
     |       added/removed from the distribution.
     |  
     |    'remove' -- a string or list of strings naming packages to be removed
     |       from the distribution if this feature is *not* included.  If the
     |       feature *is* included, this argument is ignored.  This argument exists
     |       to support removing features that "crosscut" a distribution, such as
     |       defining a 'tests' feature that removes all the 'tests' subpackages
     |       provided by other features.  The default for this argument is an empty
     |       list.  (Note: the named package(s) or modules must exist in the base
     |       distribution when the 'setup()' function is initially called.)
     |  
     |    other keywords -- any other keyword arguments are saved, and passed to
     |       the distribution's 'include()' and 'exclude()' methods when the
     |       feature is included or excluded, respectively.  So, for example, you
     |       could pass 'packages=["a","b"]' to cause packages 'a' and 'b' to be
     |       added or removed from the distribution as appropriate.
     |  
     |  A feature must include at least one 'requires', 'remove', or other
     |  keyword argument.  Otherwise, it can't affect the distribution in any way.
     |  Note also that you can subclass 'Feature' to create your own specialized
     |  feature types that modify the distribution in other ways when included or
     |  excluded.  See the docstrings for the various methods here for more detail.
     |  Aside from the methods, the only feature attributes that distributions look
     |  at are 'description' and 'optional'.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, description, standard=False, available=True, optional=True, require_features=(), remove=(), **extras)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  exclude_from(self, dist)
     |      Ensure feature is excluded from distribution
     |      
     |      You may override this in a subclass to perform additional operations on
     |      the distribution.  This method will be called at most once per
     |      feature, and only after all included features have been asked to
     |      include themselves.
     |  
     |  include_by_default(self)
     |      Should this feature be included by default?
     |  
     |  include_in(self, dist)
     |      Ensure feature and its requirements are included in distribution
     |      
     |      You may override this in a subclass to perform additional operations on
     |      the distribution.  Note that this method may be called more than once
     |      per feature, and so should be idempotent.
     |  
     |  validate(self, dist)
     |      Verify that feature makes sense in context of distribution
     |      
     |      This method is called by the distribution just before it parses its
     |      command line.  It checks to ensure that the 'remove' attribute, if any,
     |      contains only valid package/module names that are present in the base
     |      distribution when 'setup()' is called.  You may override it in a
     |      subclass to perform any other required validation of the feature
     |      against a target distribution.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  warn_deprecated()
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Require(builtins.object)
     |  Require(name, requested_version, module, homepage='', attribute=None, format=None)
     |  
     |  A prerequisite to building or installing a distribution
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, requested_version, module, homepage='', attribute=None, format=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  full_name(self)
     |      Return full package/distribution name, w/version
     |  
     |  get_version(self, paths=None, default='unknown')
     |      Get version number of installed module, 'None', or 'default'
     |      
     |      Search 'paths' for module.  If not found, return 'None'.  If found,
     |      return the extracted version attribute, or 'default' if no version
     |      attribute was specified, or the value cannot be determined without
     |      importing the module.  The version is formatted according to the
     |      requirement's version format (if any), unless it is 'None' or the
     |      supplied 'default'.
     |  
     |  is_current(self, paths=None)
     |      Return true if dependency is present and up-to-date on 'paths'
     |  
     |  is_present(self, paths=None)
     |      Return true if dependency is present on 'paths'
     |  
     |  version_ok(self, version)
     |      Is 'version' sufficiently up-to-date?
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SetuptoolsDeprecationWarning(builtins.Warning)
     |  Base class for warning deprecations in ``setuptools``
     |  
     |  This class is not derived from ``DeprecationWarning``, and as such is
     |  visible by default.
     |  
     |  Method resolution order:
     |      SetuptoolsDeprecationWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Warning:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Warning:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    __metaclass__ = class type(object)
     |  type(object_or_name, bases, dict)
     |  type(object) -> the object's type
     |  type(name, bases, dict) -> a new type
     |  
     |  Methods defined here:
     |  
     |  __call__(self, /, *args, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self, /)
     |      Specialized __dir__ implementation for types.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __instancecheck__(self, instance, /)
     |      Check if an object is an instance.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __sizeof__(self, /)
     |      Return memory consumption of the type object.
     |  
     |  __subclasscheck__(self, subclass, /)
     |      Check if a class is a subclass.
     |  
     |  __subclasses__(self, /)
     |      Return a list of immediate subclasses.
     |  
     |  mro(self, /)
     |      Return a type's method resolution order.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  __prepare__(...)
     |      __prepare__() -> dict
     |      used to create the namespace for the class statement
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __abstractmethods__
     |  
     |  __dict__
     |  
     |  __text_signature__
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __base__ = <class 'object'>
     |      The most base type
     |  
     |  __bases__ = (<class 'object'>,)
     |  
     |  __basicsize__ = 864
     |  
     |  __dictoffset__ = 264
     |  
     |  __flags__ = 2148291584
     |  
     |  __itemsize__ = 40
     |  
     |  __mro__ = (<class 'type'>, <class 'object'>)
     |  
     |  __weakrefoffset__ = 368

FUNCTIONS
    find_namespace_packages = find(where='.', exclude=(), include=('*',)) method of builtins.type instance
        Return a list all Python packages found within directory 'where'
        
        'where' is the root directory which will be searched for packages.  It
        should be supplied as a "cross-platform" (i.e. URL-style) path; it will
        be converted to the appropriate local path syntax.
        
        'exclude' is a sequence of package names to exclude; '*' can be used
        as a wildcard in the names, such that 'foo.*' will exclude all
        subpackages of 'foo' (but not 'foo' itself).
        
        'include' is a sequence of package names to include.  If it's
        specified, only the named packages will be included.  If it's not
        specified, all found packages will be included.  'include' can contain
        shell style wildcard patterns just like 'exclude'.
    
    find_packages = find(where='.', exclude=(), include=('*',)) method of builtins.type instance
        Return a list all Python packages found within directory 'where'
        
        'where' is the root directory which will be searched for packages.  It
        should be supplied as a "cross-platform" (i.e. URL-style) path; it will
        be converted to the appropriate local path syntax.
        
        'exclude' is a sequence of package names to exclude; '*' can be used
        as a wildcard in the names, such that 'foo.*' will exclude all
        subpackages of 'foo' (but not 'foo' itself).
        
        'include' is a sequence of package names to include.  If it's
        specified, only the named packages will be included.  If it's not
        specified, all found packages will be included.  'include' can contain
        shell style wildcard patterns just like 'exclude'.
    
    setup(**attrs)
        The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
        
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
        
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
        
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.

DATA
    __all__ = ['setup', 'Distribution', 'Feature', 'Command', 'Extension',...

VERSION
    40.8.0

FILE
    c:\program files\python37\lib\site-packages\setuptools\__init__.py


