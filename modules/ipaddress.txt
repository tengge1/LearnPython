Help on module ipaddress:

NAME
    ipaddress - A fast, lightweight IPv4/IPv6 manipulation library in Python.

DESCRIPTION
    This library is used to create/poke/manipulate IPv4 and IPv6 addresses
    and networks.

CLASSES
    builtins.ValueError(builtins.Exception)
        AddressValueError
        NetmaskValueError
    _BaseAddress(_IPAddressBase)
        IPv4Address(_BaseV4, _BaseAddress)
            IPv4Interface
        IPv6Address(_BaseV6, _BaseAddress)
            IPv6Interface
    _BaseNetwork(_IPAddressBase)
        IPv4Network(_BaseV4, _BaseNetwork)
        IPv6Network(_BaseV6, _BaseNetwork)
    _BaseV4(builtins.object)
        IPv4Address(_BaseV4, _BaseAddress)
            IPv4Interface
        IPv4Network(_BaseV4, _BaseNetwork)
    _BaseV6(builtins.object)
        IPv6Address(_BaseV6, _BaseAddress)
            IPv6Interface
        IPv6Network(_BaseV6, _BaseNetwork)
    
    class AddressValueError(builtins.ValueError)
     |  A Value Error related to the address.
     |  
     |  Method resolution order:
     |      AddressValueError
     |      builtins.ValueError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ValueError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.ValueError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class IPv4Address(_BaseV4, _BaseAddress)
     |  IPv4Address(address)
     |  
     |  Represent and manipulate single IPv4 Addresses.
     |  
     |  Method resolution order:
     |      IPv4Address
     |      _BaseV4
     |      _BaseAddress
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, address)
     |      Args:
     |          address: A string or integer representing the IP
     |      
     |            Additionally, an integer can be passed, so
     |            IPv4Address('192.0.2.1') == IPv4Address(3221225985).
     |            or, more generally
     |            IPv4Address(int(IPv4Address('192.0.2.1'))) ==
     |              IPv4Address('192.0.2.1')
     |      
     |      Raises:
     |          AddressValueError: If ipaddress isn't a valid IPv4 address.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  is_global
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is link-local per RFC 3927.
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback per RFC 3330.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is multicast.
     |          See RFC 3171 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv4-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within the
     |          reserved IPv4 Network range.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 5735 3.
     |  
     |  packed
     |      The binary representation of this address.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV4:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseAddress:
     |  
     |  __add__(self, other)
     |      # Shorthand for Integer addition and subtraction. This is not
     |      # meant to ever support addition/subtraction of addresses.
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __int__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class IPv4Interface(IPv4Address)
     |  IPv4Interface(address)
     |  
     |  Represent and manipulate single IPv4 Addresses.
     |  
     |  Method resolution order:
     |      IPv4Interface
     |      IPv4Address
     |      _BaseV4
     |      _BaseAddress
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, address)
     |      Args:
     |          address: A string or integer representing the IP
     |      
     |            Additionally, an integer can be passed, so
     |            IPv4Address('192.0.2.1') == IPv4Address(3221225985).
     |            or, more generally
     |            IPv4Address(int(IPv4Address('192.0.2.1'))) ==
     |              IPv4Address('192.0.2.1')
     |      
     |      Raises:
     |          AddressValueError: If ipaddress isn't a valid IPv4 address.
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  ip
     |  
     |  with_hostmask
     |  
     |  with_netmask
     |  
     |  with_prefixlen
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from IPv4Address:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  is_global
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is link-local per RFC 3927.
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback per RFC 3330.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is multicast.
     |          See RFC 3171 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv4-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within the
     |          reserved IPv4 Network range.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 5735 3.
     |  
     |  packed
     |      The binary representation of this address.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV4:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseAddress:
     |  
     |  __add__(self, other)
     |      # Shorthand for Integer addition and subtraction. This is not
     |      # meant to ever support addition/subtraction of addresses.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __int__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __sub__(self, other)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class IPv4Network(_BaseV4, _BaseNetwork)
     |  IPv4Network(address, strict=True)
     |  
     |  This class represents and manipulates 32-bit IPv4 network + addresses..
     |  
     |  Attributes: [examples for IPv4Network('192.0.2.0/27')]
     |      .network_address: IPv4Address('192.0.2.0')
     |      .hostmask: IPv4Address('0.0.0.31')
     |      .broadcast_address: IPv4Address('192.0.2.32')
     |      .netmask: IPv4Address('255.255.255.224')
     |      .prefixlen: 27
     |  
     |  Method resolution order:
     |      IPv4Network
     |      _BaseV4
     |      _BaseNetwork
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, address, strict=True)
     |      Instantiate a new IPv4 network object.
     |      
     |      Args:
     |          address: A string or integer representing the IP [& network].
     |            '192.0.2.0/24'
     |            '192.0.2.0/255.255.255.0'
     |            '192.0.0.2/0.0.0.255'
     |            are all functionally the same in IPv4. Similarly,
     |            '192.0.2.1'
     |            '192.0.2.1/255.255.255.255'
     |            '192.0.2.1/32'
     |            are also functionally equivalent. That is to say, failing to
     |            provide a subnetmask will create an object with a mask of /32.
     |      
     |            If the mask (portion after the / in the argument) is given in
     |            dotted quad form, it is treated as a netmask if it starts with a
     |            non-zero field (e.g. /255.0.0.0 == /8) and as a hostmask if it
     |            starts with a zero field (e.g. 0.255.255.255 == /8), with the
     |            single exception of an all-zero mask which is treated as a
     |            netmask == /0. If no mask is given, a default of /32 is used.
     |      
     |            Additionally, an integer can be passed, so
     |            IPv4Network('192.0.2.1') == IPv4Network(3221225985)
     |            or, more generally
     |            IPv4Interface(int(IPv4Interface('192.0.2.1'))) ==
     |              IPv4Interface('192.0.2.1')
     |      
     |      Raises:
     |          AddressValueError: If ipaddress isn't a valid IPv4 address.
     |          NetmaskValueError: If the netmask isn't valid for
     |            an IPv4 address.
     |          ValueError: If strict is True and a network address is not
     |            supplied.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  is_global
     |      Test if this address is allocated for public networks.
     |      
     |      Returns:
     |          A boolean, True if the address is not reserved per
     |          iana-ipv4-special-registry.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV4:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseNetwork:
     |  
     |  __contains__(self, other)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __getitem__(self, n)
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __iter__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  address_exclude(self, other)
     |      Remove an address from a larger block.
     |      
     |      For example:
     |      
     |          addr1 = ip_network('192.0.2.0/28')
     |          addr2 = ip_network('192.0.2.1/32')
     |          list(addr1.address_exclude(addr2)) =
     |              [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),
     |               IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]
     |      
     |      or IPv6:
     |      
     |          addr1 = ip_network('2001:db8::1/32')
     |          addr2 = ip_network('2001:db8::1/128')
     |          list(addr1.address_exclude(addr2)) =
     |              [ip_network('2001:db8::1/128'),
     |               ip_network('2001:db8::2/127'),
     |               ip_network('2001:db8::4/126'),
     |               ip_network('2001:db8::8/125'),
     |               ...
     |               ip_network('2001:db8:8000::/33')]
     |      
     |      Args:
     |          other: An IPv4Network or IPv6Network object of the same type.
     |      
     |      Returns:
     |          An iterator of the IPv(4|6)Network objects which is self
     |          minus other.
     |      
     |      Raises:
     |          TypeError: If self and other are of differing address
     |            versions, or if other is not a network object.
     |          ValueError: If other is not completely contained by self.
     |  
     |  compare_networks(self, other)
     |      Compare two IP objects.
     |      
     |      This is only concerned about the comparison of the integer
     |      representation of the network addresses.  This means that the
     |      host bits aren't considered at all in this method.  If you want
     |      to compare host bits, you can easily enough do a
     |      'HostA._ip < HostB._ip'
     |      
     |      Args:
     |          other: An IP object.
     |      
     |      Returns:
     |          If the IP versions of self and other are the same, returns:
     |      
     |          -1 if self < other:
     |            eg: IPv4Network('192.0.2.0/25') < IPv4Network('192.0.2.128/25')
     |            IPv6Network('2001:db8::1000/124') <
     |                IPv6Network('2001:db8::2000/124')
     |          0 if self == other
     |            eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')
     |            IPv6Network('2001:db8::1000/124') ==
     |                IPv6Network('2001:db8::1000/124')
     |          1 if self > other
     |            eg: IPv4Network('192.0.2.128/25') > IPv4Network('192.0.2.0/25')
     |                IPv6Network('2001:db8::2000/124') >
     |                    IPv6Network('2001:db8::1000/124')
     |      
     |        Raises:
     |            TypeError if the IP versions are different.
     |  
     |  hosts(self)
     |      Generate Iterator over usable hosts in a network.
     |      
     |      This is like __iter__ except it doesn't return the network
     |      or broadcast addresses.
     |  
     |  overlaps(self, other)
     |      Tell if self is partly contained in other.
     |  
     |  subnet_of(self, other)
     |      Return True if this network is a subnet of other.
     |  
     |  subnets(self, prefixlen_diff=1, new_prefix=None)
     |      The subnets which join to make the current subnet.
     |      
     |      In the case that self contains only one IP
     |      (self._prefixlen == 32 for IPv4 or self._prefixlen == 128
     |      for IPv6), yield an iterator with just ourself.
     |      
     |      Args:
     |          prefixlen_diff: An integer, the amount the prefix length
     |            should be increased by. This should not be set if
     |            new_prefix is also set.
     |          new_prefix: The desired new prefix length. This must be a
     |            larger number (smaller prefix) than the existing prefix.
     |            This should not be set if prefixlen_diff is also set.
     |      
     |      Returns:
     |          An iterator of IPv(4|6) objects.
     |      
     |      Raises:
     |          ValueError: The prefixlen_diff is too small or too large.
     |              OR
     |          prefixlen_diff and new_prefix are both set or new_prefix
     |            is a smaller number than the current prefix (smaller
     |            number means a larger network)
     |  
     |  supernet(self, prefixlen_diff=1, new_prefix=None)
     |      The supernet containing the current network.
     |      
     |      Args:
     |          prefixlen_diff: An integer, the amount the prefix length of
     |            the network should be decreased by.  For example, given a
     |            /24 network and a prefixlen_diff of 3, a supernet with a
     |            /21 netmask is returned.
     |      
     |      Returns:
     |          An IPv4 network object.
     |      
     |      Raises:
     |          ValueError: If self.prefixlen - prefixlen_diff < 0. I.e., you have
     |            a negative prefix length.
     |              OR
     |          If prefixlen_diff and new_prefix are both set or new_prefix is a
     |            larger number than the current prefix (larger number means a
     |            smaller network)
     |  
     |  supernet_of(self, other)
     |      Return True if this network is a supernet of other.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseNetwork:
     |  
     |  broadcast_address
     |  
     |  hostmask
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 4291.
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback address as defined in
     |          RFC 2373 2.5.3.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is a multicast address.
     |          See RFC 2373 2.7 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv4-special-registry or iana-ipv6-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within one of the
     |          reserved IPv6 Network ranges.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 2373 2.5.2.
     |  
     |  num_addresses
     |      Number of hosts in the current subnet.
     |  
     |  prefixlen
     |  
     |  with_hostmask
     |  
     |  with_netmask
     |  
     |  with_prefixlen
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _IPAddressBase:
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class IPv6Address(_BaseV6, _BaseAddress)
     |  IPv6Address(address)
     |  
     |  Represent and manipulate single IPv6 Addresses.
     |  
     |  Method resolution order:
     |      IPv6Address
     |      _BaseV6
     |      _BaseAddress
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, address)
     |      Instantiate a new IPv6 address object.
     |      
     |      Args:
     |          address: A string or integer representing the IP
     |      
     |            Additionally, an integer can be passed, so
     |            IPv6Address('2001:db8::') ==
     |              IPv6Address(42540766411282592856903984951653826560)
     |            or, more generally
     |            IPv6Address(int(IPv6Address('2001:db8::'))) ==
     |              IPv6Address('2001:db8::')
     |      
     |      Raises:
     |          AddressValueError: If address isn't a valid IPv6 address.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ipv4_mapped
     |      Return the IPv4 mapped address.
     |      
     |      Returns:
     |          If the IPv6 address is a v4 mapped address, return the
     |          IPv4 mapped address. Return None otherwise.
     |  
     |  is_global
     |      Test if this address is allocated for public networks.
     |      
     |      Returns:
     |          A boolean, true if the address is not reserved per
     |          iana-ipv6-special-registry.
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 4291.
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback address as defined in
     |          RFC 2373 2.5.3.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is a multicast address.
     |          See RFC 2373 2.7 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv6-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within one of the
     |          reserved IPv6 Network ranges.
     |  
     |  is_site_local
     |      Test if the address is reserved for site-local.
     |      
     |      Note that the site-local address space has been deprecated by RFC 3879.
     |      Use is_private to test if this address is in the space of unique local
     |      addresses as defined by RFC 4193.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 3513 2.5.6.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 2373 2.5.2.
     |  
     |  packed
     |      The binary representation of this address.
     |  
     |  sixtofour
     |      Return the IPv4 6to4 embedded address.
     |      
     |      Returns:
     |          The IPv4 6to4-embedded address if present or None if the
     |          address doesn't appear to contain a 6to4 embedded address.
     |  
     |  teredo
     |      Tuple of embedded teredo IPs.
     |      
     |      Returns:
     |          Tuple of the (server, client) IPs or None if the address
     |          doesn't appear to be a teredo address (doesn't start with
     |          2001::/32)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV6:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseAddress:
     |  
     |  __add__(self, other)
     |      # Shorthand for Integer addition and subtraction. This is not
     |      # meant to ever support addition/subtraction of addresses.
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __int__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__(self, other)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class IPv6Interface(IPv6Address)
     |  IPv6Interface(address)
     |  
     |  Represent and manipulate single IPv6 Addresses.
     |  
     |  Method resolution order:
     |      IPv6Interface
     |      IPv6Address
     |      _BaseV6
     |      _BaseAddress
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, address)
     |      Instantiate a new IPv6 address object.
     |      
     |      Args:
     |          address: A string or integer representing the IP
     |      
     |            Additionally, an integer can be passed, so
     |            IPv6Address('2001:db8::') ==
     |              IPv6Address(42540766411282592856903984951653826560)
     |            or, more generally
     |            IPv6Address(int(IPv6Address('2001:db8::'))) ==
     |              IPv6Address('2001:db8::')
     |      
     |      Raises:
     |          AddressValueError: If address isn't a valid IPv6 address.
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  ip
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback address as defined in
     |          RFC 2373 2.5.3.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 2373 2.5.2.
     |  
     |  with_hostmask
     |  
     |  with_netmask
     |  
     |  with_prefixlen
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from IPv6Address:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ipv4_mapped
     |      Return the IPv4 mapped address.
     |      
     |      Returns:
     |          If the IPv6 address is a v4 mapped address, return the
     |          IPv4 mapped address. Return None otherwise.
     |  
     |  is_global
     |      Test if this address is allocated for public networks.
     |      
     |      Returns:
     |          A boolean, true if the address is not reserved per
     |          iana-ipv6-special-registry.
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 4291.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is a multicast address.
     |          See RFC 2373 2.7 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv6-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within one of the
     |          reserved IPv6 Network ranges.
     |  
     |  is_site_local
     |      Test if the address is reserved for site-local.
     |      
     |      Note that the site-local address space has been deprecated by RFC 3879.
     |      Use is_private to test if this address is in the space of unique local
     |      addresses as defined by RFC 4193.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 3513 2.5.6.
     |  
     |  packed
     |      The binary representation of this address.
     |  
     |  sixtofour
     |      Return the IPv4 6to4 embedded address.
     |      
     |      Returns:
     |          The IPv4 6to4-embedded address if present or None if the
     |          address doesn't appear to contain a 6to4 embedded address.
     |  
     |  teredo
     |      Tuple of embedded teredo IPs.
     |      
     |      Returns:
     |          Tuple of the (server, client) IPs or None if the address
     |          doesn't appear to be a teredo address (doesn't start with
     |          2001::/32)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV6:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseAddress:
     |  
     |  __add__(self, other)
     |      # Shorthand for Integer addition and subtraction. This is not
     |      # meant to ever support addition/subtraction of addresses.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __int__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __sub__(self, other)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class IPv6Network(_BaseV6, _BaseNetwork)
     |  IPv6Network(address, strict=True)
     |  
     |  This class represents and manipulates 128-bit IPv6 networks.
     |  
     |  Attributes: [examples for IPv6('2001:db8::1000/124')]
     |      .network_address: IPv6Address('2001:db8::1000')
     |      .hostmask: IPv6Address('::f')
     |      .broadcast_address: IPv6Address('2001:db8::100f')
     |      .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')
     |      .prefixlen: 124
     |  
     |  Method resolution order:
     |      IPv6Network
     |      _BaseV6
     |      _BaseNetwork
     |      _IPAddressBase
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, address, strict=True)
     |      Instantiate a new IPv6 Network object.
     |      
     |      Args:
     |          address: A string or integer representing the IPv6 network or the
     |            IP and prefix/netmask.
     |            '2001:db8::/128'
     |            '2001:db8:0000:0000:0000:0000:0000:0000/128'
     |            '2001:db8::'
     |            are all functionally the same in IPv6.  That is to say,
     |            failing to provide a subnetmask will create an object with
     |            a mask of /128.
     |      
     |            Additionally, an integer can be passed, so
     |            IPv6Network('2001:db8::') ==
     |              IPv6Network(42540766411282592856903984951653826560)
     |            or, more generally
     |            IPv6Network(int(IPv6Network('2001:db8::'))) ==
     |              IPv6Network('2001:db8::')
     |      
     |          strict: A boolean. If true, ensure that we have been passed
     |            A true network address, eg, 2001:db8::1000/124 and not an
     |            IP address on a network, eg, 2001:db8::1/124.
     |      
     |      Raises:
     |          AddressValueError: If address isn't a valid IPv6 address.
     |          NetmaskValueError: If the netmask isn't valid for
     |            an IPv6 address.
     |          ValueError: If strict was True and a network address was not
     |            supplied.
     |  
     |  hosts(self)
     |      Generate Iterator over usable hosts in a network.
     |      
     |      This is like __iter__ except it doesn't return the
     |      Subnet-Router anycast address.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  is_site_local
     |      Test if the address is reserved for site-local.
     |      
     |      Note that the site-local address space has been deprecated by RFC 3879.
     |      Use is_private to test if this address is in the space of unique local
     |      addresses as defined by RFC 4193.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 3513 2.5.6.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseV6:
     |  
     |  max_prefixlen
     |  
     |  version
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseNetwork:
     |  
     |  __contains__(self, other)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __ge__(self, other, NotImplemented=NotImplemented)
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |  
     |  __getitem__(self, n)
     |  
     |  __gt__(self, other, NotImplemented=NotImplemented)
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __iter__(self)
     |  
     |  __le__(self, other, NotImplemented=NotImplemented)
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  address_exclude(self, other)
     |      Remove an address from a larger block.
     |      
     |      For example:
     |      
     |          addr1 = ip_network('192.0.2.0/28')
     |          addr2 = ip_network('192.0.2.1/32')
     |          list(addr1.address_exclude(addr2)) =
     |              [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),
     |               IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]
     |      
     |      or IPv6:
     |      
     |          addr1 = ip_network('2001:db8::1/32')
     |          addr2 = ip_network('2001:db8::1/128')
     |          list(addr1.address_exclude(addr2)) =
     |              [ip_network('2001:db8::1/128'),
     |               ip_network('2001:db8::2/127'),
     |               ip_network('2001:db8::4/126'),
     |               ip_network('2001:db8::8/125'),
     |               ...
     |               ip_network('2001:db8:8000::/33')]
     |      
     |      Args:
     |          other: An IPv4Network or IPv6Network object of the same type.
     |      
     |      Returns:
     |          An iterator of the IPv(4|6)Network objects which is self
     |          minus other.
     |      
     |      Raises:
     |          TypeError: If self and other are of differing address
     |            versions, or if other is not a network object.
     |          ValueError: If other is not completely contained by self.
     |  
     |  compare_networks(self, other)
     |      Compare two IP objects.
     |      
     |      This is only concerned about the comparison of the integer
     |      representation of the network addresses.  This means that the
     |      host bits aren't considered at all in this method.  If you want
     |      to compare host bits, you can easily enough do a
     |      'HostA._ip < HostB._ip'
     |      
     |      Args:
     |          other: An IP object.
     |      
     |      Returns:
     |          If the IP versions of self and other are the same, returns:
     |      
     |          -1 if self < other:
     |            eg: IPv4Network('192.0.2.0/25') < IPv4Network('192.0.2.128/25')
     |            IPv6Network('2001:db8::1000/124') <
     |                IPv6Network('2001:db8::2000/124')
     |          0 if self == other
     |            eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')
     |            IPv6Network('2001:db8::1000/124') ==
     |                IPv6Network('2001:db8::1000/124')
     |          1 if self > other
     |            eg: IPv4Network('192.0.2.128/25') > IPv4Network('192.0.2.0/25')
     |                IPv6Network('2001:db8::2000/124') >
     |                    IPv6Network('2001:db8::1000/124')
     |      
     |        Raises:
     |            TypeError if the IP versions are different.
     |  
     |  overlaps(self, other)
     |      Tell if self is partly contained in other.
     |  
     |  subnet_of(self, other)
     |      Return True if this network is a subnet of other.
     |  
     |  subnets(self, prefixlen_diff=1, new_prefix=None)
     |      The subnets which join to make the current subnet.
     |      
     |      In the case that self contains only one IP
     |      (self._prefixlen == 32 for IPv4 or self._prefixlen == 128
     |      for IPv6), yield an iterator with just ourself.
     |      
     |      Args:
     |          prefixlen_diff: An integer, the amount the prefix length
     |            should be increased by. This should not be set if
     |            new_prefix is also set.
     |          new_prefix: The desired new prefix length. This must be a
     |            larger number (smaller prefix) than the existing prefix.
     |            This should not be set if prefixlen_diff is also set.
     |      
     |      Returns:
     |          An iterator of IPv(4|6) objects.
     |      
     |      Raises:
     |          ValueError: The prefixlen_diff is too small or too large.
     |              OR
     |          prefixlen_diff and new_prefix are both set or new_prefix
     |            is a smaller number than the current prefix (smaller
     |            number means a larger network)
     |  
     |  supernet(self, prefixlen_diff=1, new_prefix=None)
     |      The supernet containing the current network.
     |      
     |      Args:
     |          prefixlen_diff: An integer, the amount the prefix length of
     |            the network should be decreased by.  For example, given a
     |            /24 network and a prefixlen_diff of 3, a supernet with a
     |            /21 netmask is returned.
     |      
     |      Returns:
     |          An IPv4 network object.
     |      
     |      Raises:
     |          ValueError: If self.prefixlen - prefixlen_diff < 0. I.e., you have
     |            a negative prefix length.
     |              OR
     |          If prefixlen_diff and new_prefix are both set or new_prefix is a
     |            larger number than the current prefix (larger number means a
     |            smaller network)
     |  
     |  supernet_of(self, other)
     |      Return True if this network is a supernet of other.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseNetwork:
     |  
     |  broadcast_address
     |  
     |  hostmask
     |  
     |  is_global
     |      Test if this address is allocated for public networks.
     |      
     |      Returns:
     |          A boolean, True if the address is not reserved per
     |          iana-ipv4-special-registry or iana-ipv6-special-registry.
     |  
     |  is_link_local
     |      Test if the address is reserved for link-local.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per RFC 4291.
     |  
     |  is_loopback
     |      Test if the address is a loopback address.
     |      
     |      Returns:
     |          A boolean, True if the address is a loopback address as defined in
     |          RFC 2373 2.5.3.
     |  
     |  is_multicast
     |      Test if the address is reserved for multicast use.
     |      
     |      Returns:
     |          A boolean, True if the address is a multicast address.
     |          See RFC 2373 2.7 for details.
     |  
     |  is_private
     |      Test if this address is allocated for private networks.
     |      
     |      Returns:
     |          A boolean, True if the address is reserved per
     |          iana-ipv4-special-registry or iana-ipv6-special-registry.
     |  
     |  is_reserved
     |      Test if the address is otherwise IETF reserved.
     |      
     |      Returns:
     |          A boolean, True if the address is within one of the
     |          reserved IPv6 Network ranges.
     |  
     |  is_unspecified
     |      Test if the address is unspecified.
     |      
     |      Returns:
     |          A boolean, True if this is the unspecified address as defined in
     |          RFC 2373 2.5.2.
     |  
     |  num_addresses
     |      Number of hosts in the current subnet.
     |  
     |  prefixlen
     |  
     |  with_hostmask
     |  
     |  with_netmask
     |  
     |  with_prefixlen
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from _IPAddressBase:
     |  
     |  __reduce__(self)
     |      Helper for pickle.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _IPAddressBase:
     |  
     |  compressed
     |      Return the shorthand version of the IP address as a string.
     |  
     |  exploded
     |      Return the longhand version of the IP address as a string.
     |  
     |  reverse_pointer
     |      The name of the reverse DNS pointer for the IP address, e.g.:
     |      >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
     |      '1.0.0.127.in-addr.arpa'
     |      >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
     |      '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
    
    class NetmaskValueError(builtins.ValueError)
     |  A Value Error related to the netmask.
     |  
     |  Method resolution order:
     |      NetmaskValueError
     |      builtins.ValueError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ValueError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.ValueError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    collapse_addresses(addresses)
        Collapse a list of IP objects.
        
        Example:
            collapse_addresses([IPv4Network('192.0.2.0/25'),
                                IPv4Network('192.0.2.128/25')]) ->
                               [IPv4Network('192.0.2.0/24')]
        
        Args:
            addresses: An iterator of IPv4Network or IPv6Network objects.
        
        Returns:
            An iterator of the collapsed IPv(4|6)Network objects.
        
        Raises:
            TypeError: If passed a list of mixed version objects.
    
    get_mixed_type_key(obj)
        Return a key suitable for sorting between networks and addresses.
        
        Address and Network objects are not sortable by default; they're
        fundamentally different so the expression
        
            IPv4Address('192.0.2.0') <= IPv4Network('192.0.2.0/24')
        
        doesn't make any sense.  There are some times however, where you may wish
        to have ipaddress sort these for you anyway. If you need to do this, you
        can use this function as the key= argument to sorted().
        
        Args:
          obj: either a Network or Address object.
        Returns:
          appropriate key.
    
    ip_address(address)
        Take an IP string/int and return an object of the correct type.
        
        Args:
            address: A string or integer, the IP address.  Either IPv4 or
              IPv6 addresses may be supplied; integers less than 2**32 will
              be considered to be IPv4 by default.
        
        Returns:
            An IPv4Address or IPv6Address object.
        
        Raises:
            ValueError: if the *address* passed isn't either a v4 or a v6
              address
    
    ip_interface(address)
        Take an IP string/int and return an object of the correct type.
        
        Args:
            address: A string or integer, the IP address.  Either IPv4 or
              IPv6 addresses may be supplied; integers less than 2**32 will
              be considered to be IPv4 by default.
        
        Returns:
            An IPv4Interface or IPv6Interface object.
        
        Raises:
            ValueError: if the string passed isn't either a v4 or a v6
              address.
        
        Notes:
            The IPv?Interface classes describe an Address on a particular
            Network, so they're basically a combination of both the Address
            and Network classes.
    
    ip_network(address, strict=True)
        Take an IP string/int and return an object of the correct type.
        
        Args:
            address: A string or integer, the IP network.  Either IPv4 or
              IPv6 networks may be supplied; integers less than 2**32 will
              be considered to be IPv4 by default.
        
        Returns:
            An IPv4Network or IPv6Network object.
        
        Raises:
            ValueError: if the string passed isn't either a v4 or a v6
              address. Or if the network has host bits set.
    
    summarize_address_range(first, last)
        Summarize a network range given the first and last IP addresses.
        
        Example:
            >>> list(summarize_address_range(IPv4Address('192.0.2.0'),
            ...                              IPv4Address('192.0.2.130')))
            ...                                #doctest: +NORMALIZE_WHITESPACE
            [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),
             IPv4Network('192.0.2.130/32')]
        
        Args:
            first: the first IPv4Address or IPv6Address in the range.
            last: the last IPv4Address or IPv6Address in the range.
        
        Returns:
            An iterator of the summarized IPv(4|6) network objects.
        
        Raise:
            TypeError:
                If the first and last objects are not IP addresses.
                If the first and last objects are not the same version.
            ValueError:
                If the last object is not greater than the first.
                If the version of the first address is not 4 or 6.
    
    v4_int_to_packed(address)
        Represent an address as 4 packed bytes in network (big-endian) order.
        
        Args:
            address: An integer representation of an IPv4 IP address.
        
        Returns:
            The integer address packed as 4 bytes in network (big-endian) order.
        
        Raises:
            ValueError: If the integer is negative or too large to be an
              IPv4 IP address.
    
    v6_int_to_packed(address)
        Represent an address as 16 packed bytes in network (big-endian) order.
        
        Args:
            address: An integer representation of an IPv6 IP address.
        
        Returns:
            The integer address packed as 16 bytes in network (big-endian) order.

DATA
    IPV4LENGTH = 32
    IPV6LENGTH = 128

VERSION
    1.0

FILE
    c:\program files\python37\lib\ipaddress.py


