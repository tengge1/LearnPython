Help on module _socket:

NAME
    _socket - Implementation module for socket operations.

DESCRIPTION
    See the socket module for documentation.

CLASSES
    builtins.object
        socket
    
    SocketType = class socket(builtins.object)
     |  socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object
     |  socket(family=-1, type=-1, proto=-1, fileno=None) -> socket object
     |  
     |  Open a socket of the given type.  The family argument specifies the
     |  address family; it defaults to AF_INET.  The type argument specifies
     |  whether this is a stream (SOCK_STREAM, this is the default)
     |  or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,
     |  specifying the default protocol.  Keyword arguments are accepted.
     |  The socket is created as non-inheritable.
     |  
     |  When a fileno is passed in, family, type and proto are auto-detected,
     |  unless they are explicitly set.
     |  
     |  A socket object represents one endpoint of a network connection.
     |  
     |  Methods of socket objects (keyword arguments not allowed):
     |  
     |  _accept() -- accept connection, returning new socket fd and client address
     |  bind(addr) -- bind the socket to a local address
     |  close() -- close the socket
     |  connect(addr) -- connect the socket to a remote address
     |  connect_ex(addr) -- connect, return an error code instead of an exception
     |  dup() -- return a new socket fd duplicated from fileno()
     |  fileno() -- return underlying file descriptor
     |  getpeername() -- return remote address [*]
     |  getsockname() -- return local address
     |  getsockopt(level, optname[, buflen]) -- get socket options
     |  gettimeout() -- return timeout or None
     |  listen([n]) -- start listening for incoming connections
     |  recv(buflen[, flags]) -- receive data
     |  recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)
     |  recvfrom(buflen[, flags]) -- receive data and sender's address
     |  recvfrom_into(buffer[, nbytes, [, flags])
     |    -- receive data and sender's address (into a buffer)
     |  sendall(data[, flags]) -- send all data
     |  send(data[, flags]) -- send data, may not send all of it
     |  sendto(data[, flags], addr) -- send data to a given address
     |  setblocking(0 | 1) -- set or clear the blocking I/O flag
     |  getblocking() -- return True if socket is blocking, False if non-blocking
     |  setsockopt(level, optname, value[, optlen]) -- set socket options
     |  settimeout(None | float) -- set or clear the timeout
     |  shutdown(how) -- shut down traffic in one or both directions
     |  if_nameindex() -- return all network interface indices and names
     |  if_nametoindex(name) -- return the corresponding interface index
     |  if_indextoname(index) -- return the corresponding interface name
     |  
     |   [*] not available on all platforms!
     |  
     |  Methods defined here:
     |  
     |  __del__(...)
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  bind(...)
     |      bind(address)
     |      
     |      Bind the socket to a local address.  For IP sockets, the address is a
     |      pair (host, port); the host must refer to the local host. For raw packet
     |      sockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])
     |  
     |  close(...)
     |      close()
     |      
     |      Close the socket.  It cannot be used after this call.
     |  
     |  connect(...)
     |      connect(address)
     |      
     |      Connect the socket to a remote address.  For IP sockets, the address
     |      is a pair (host, port).
     |  
     |  connect_ex(...)
     |      connect_ex(address) -> errno
     |      
     |      This is like connect(address), but returns an error code (the errno value)
     |      instead of raising an exception when an error occurs.
     |  
     |  detach(...)
     |      detach()
     |      
     |      Close the socket object without closing the underlying file descriptor.
     |      The object cannot be used after this call, but the file descriptor
     |      can be reused for other purposes.  The file descriptor is returned.
     |  
     |  fileno(...)
     |      fileno() -> integer
     |      
     |      Return the integer file descriptor of the socket.
     |  
     |  getblocking(...)
     |      getblocking()
     |      
     |      Returns True if socket is in blocking mode, or False if it
     |      is in non-blocking mode.
     |  
     |  getpeername(...)
     |      getpeername() -> address info
     |      
     |      Return the address of the remote endpoint.  For IP sockets, the address
     |      info is a pair (hostaddr, port).
     |  
     |  getsockname(...)
     |      getsockname() -> address info
     |      
     |      Return the address of the local endpoint.  For IP sockets, the address
     |      info is a pair (hostaddr, port).
     |  
     |  getsockopt(...)
     |      getsockopt(level, option[, buffersize]) -> value
     |      
     |      Get a socket option.  See the Unix manual for level and option.
     |      If a nonzero buffersize argument is given, the return value is a
     |      string of that length; otherwise it is an integer.
     |  
     |  gettimeout(...)
     |      gettimeout() -> timeout
     |      
     |      Returns the timeout in seconds (float) associated with socket 
     |      operations. A timeout of None indicates that timeouts on socket 
     |      operations are disabled.
     |  
     |  ioctl(...)
     |      ioctl(cmd, option) -> long
     |      
     |      Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are
     |      SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.
     |      SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).
     |      SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default
     |  
     |  listen(...)
     |      listen([backlog])
     |      
     |      Enable a server to accept connections.  If backlog is specified, it must be
     |      at least 0 (if it is lower, it is set to 0); it specifies the number of
     |      unaccepted connections that the system will allow before refusing new
     |      connections. If not specified, a default reasonable value is chosen.
     |  
     |  recv(...)
     |      recv(buffersize[, flags]) -> data
     |      
     |      Receive up to buffersize bytes from the socket.  For the optional flags
     |      argument, see the Unix manual.  When no data is available, block until
     |      at least one byte is available or until the remote end is closed.  When
     |      the remote end is closed and all data is read, return the empty string.
     |  
     |  recv_into(...)
     |      recv_into(buffer, [nbytes[, flags]]) -> nbytes_read
     |      
     |      A version of recv() that stores its data into a buffer rather than creating 
     |      a new string.  Receive up to buffersize bytes from the socket.  If buffersize 
     |      is not specified (or 0), receive up to the size available in the given buffer.
     |      
     |      See recv() for documentation about the flags.
     |  
     |  recvfrom(...)
     |      recvfrom(buffersize[, flags]) -> (data, address info)
     |      
     |      Like recv(buffersize, flags) but also return the sender's address info.
     |  
     |  recvfrom_into(...)
     |      recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)
     |      
     |      Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.
     |  
     |  send(...)
     |      send(data[, flags]) -> count
     |      
     |      Send a data string to the socket.  For the optional flags
     |      argument, see the Unix manual.  Return the number of bytes
     |      sent; this may be less than len(data) if the network is busy.
     |  
     |  sendall(...)
     |      sendall(data[, flags])
     |      
     |      Send a data string to the socket.  For the optional flags
     |      argument, see the Unix manual.  This calls send() repeatedly
     |      until all data is sent.  If an error occurs, it's impossible
     |      to tell how much data has been sent.
     |  
     |  sendto(...)
     |      sendto(data[, flags], address) -> count
     |      
     |      Like send(data, flags) but allows specifying the destination address.
     |      For IP sockets, the address is a pair (hostaddr, port).
     |  
     |  setblocking(...)
     |      setblocking(flag)
     |      
     |      Set the socket to blocking (flag is true) or non-blocking (false).
     |      setblocking(True) is equivalent to settimeout(None);
     |      setblocking(False) is equivalent to settimeout(0.0).
     |  
     |  setsockopt(...)
     |      setsockopt(level, option, value: int)
     |      setsockopt(level, option, value: buffer)
     |      setsockopt(level, option, None, optlen: int)
     |      
     |      Set a socket option.  See the Unix manual for level and option.
     |      The value argument can either be an integer, a string buffer, or 
     |      None, optlen.
     |  
     |  settimeout(...)
     |      settimeout(timeout)
     |      
     |      Set a timeout on socket operations.  'timeout' can be a float,
     |      giving in seconds, or None.  Setting a timeout of None disables
     |      the timeout feature and is equivalent to setblocking(1).
     |      Setting a timeout of zero is the same as setblocking(0).
     |  
     |  share(...)
     |      share(process_id) -> bytes
     |      
     |      Share the socket with another process.  The target process id
     |      must be provided and the resulting bytes object passed to the target
     |      process.  There the shared socket can be instantiated by calling
     |      socket.fromshare().
     |  
     |  shutdown(...)
     |      shutdown(flag)
     |      
     |      Shut down the reading side of the socket (flag == SHUT_RD), the writing side
     |      of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  family
     |      the socket family
     |  
     |  proto
     |      the socket protocol
     |  
     |  timeout
     |      the socket timeout
     |  
     |  type
     |      the socket type
    
    class socket(builtins.object)
     |  socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object
     |  socket(family=-1, type=-1, proto=-1, fileno=None) -> socket object
     |  
     |  Open a socket of the given type.  The family argument specifies the
     |  address family; it defaults to AF_INET.  The type argument specifies
     |  whether this is a stream (SOCK_STREAM, this is the default)
     |  or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,
     |  specifying the default protocol.  Keyword arguments are accepted.
     |  The socket is created as non-inheritable.
     |  
     |  When a fileno is passed in, family, type and proto are auto-detected,
     |  unless they are explicitly set.
     |  
     |  A socket object represents one endpoint of a network connection.
     |  
     |  Methods of socket objects (keyword arguments not allowed):
     |  
     |  _accept() -- accept connection, returning new socket fd and client address
     |  bind(addr) -- bind the socket to a local address
     |  close() -- close the socket
     |  connect(addr) -- connect the socket to a remote address
     |  connect_ex(addr) -- connect, return an error code instead of an exception
     |  dup() -- return a new socket fd duplicated from fileno()
     |  fileno() -- return underlying file descriptor
     |  getpeername() -- return remote address [*]
     |  getsockname() -- return local address
     |  getsockopt(level, optname[, buflen]) -- get socket options
     |  gettimeout() -- return timeout or None
     |  listen([n]) -- start listening for incoming connections
     |  recv(buflen[, flags]) -- receive data
     |  recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)
     |  recvfrom(buflen[, flags]) -- receive data and sender's address
     |  recvfrom_into(buffer[, nbytes, [, flags])
     |    -- receive data and sender's address (into a buffer)
     |  sendall(data[, flags]) -- send all data
     |  send(data[, flags]) -- send data, may not send all of it
     |  sendto(data[, flags], addr) -- send data to a given address
     |  setblocking(0 | 1) -- set or clear the blocking I/O flag
     |  getblocking() -- return True if socket is blocking, False if non-blocking
     |  setsockopt(level, optname, value[, optlen]) -- set socket options
     |  settimeout(None | float) -- set or clear the timeout
     |  shutdown(how) -- shut down traffic in one or both directions
     |  if_nameindex() -- return all network interface indices and names
     |  if_nametoindex(name) -- return the corresponding interface index
     |  if_indextoname(index) -- return the corresponding interface name
     |  
     |   [*] not available on all platforms!
     |  
     |  Methods defined here:
     |  
     |  __del__(...)
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  bind(...)
     |      bind(address)
     |      
     |      Bind the socket to a local address.  For IP sockets, the address is a
     |      pair (host, port); the host must refer to the local host. For raw packet
     |      sockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])
     |  
     |  close(...)
     |      close()
     |      
     |      Close the socket.  It cannot be used after this call.
     |  
     |  connect(...)
     |      connect(address)
     |      
     |      Connect the socket to a remote address.  For IP sockets, the address
     |      is a pair (host, port).
     |  
     |  connect_ex(...)
     |      connect_ex(address) -> errno
     |      
     |      This is like connect(address), but returns an error code (the errno value)
     |      instead of raising an exception when an error occurs.
     |  
     |  detach(...)
     |      detach()
     |      
     |      Close the socket object without closing the underlying file descriptor.
     |      The object cannot be used after this call, but the file descriptor
     |      can be reused for other purposes.  The file descriptor is returned.
     |  
     |  fileno(...)
     |      fileno() -> integer
     |      
     |      Return the integer file descriptor of the socket.
     |  
     |  getblocking(...)
     |      getblocking()
     |      
     |      Returns True if socket is in blocking mode, or False if it
     |      is in non-blocking mode.
     |  
     |  getpeername(...)
     |      getpeername() -> address info
     |      
     |      Return the address of the remote endpoint.  For IP sockets, the address
     |      info is a pair (hostaddr, port).
     |  
     |  getsockname(...)
     |      getsockname() -> address info
     |      
     |      Return the address of the local endpoint.  For IP sockets, the address
     |      info is a pair (hostaddr, port).
     |  
     |  getsockopt(...)
     |      getsockopt(level, option[, buffersize]) -> value
     |      
     |      Get a socket option.  See the Unix manual for level and option.
     |      If a nonzero buffersize argument is given, the return value is a
     |      string of that length; otherwise it is an integer.
     |  
     |  gettimeout(...)
     |      gettimeout() -> timeout
     |      
     |      Returns the timeout in seconds (float) associated with socket 
     |      operations. A timeout of None indicates that timeouts on socket 
     |      operations are disabled.
     |  
     |  ioctl(...)
     |      ioctl(cmd, option) -> long
     |      
     |      Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are
     |      SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.
     |      SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).
     |      SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default
     |  
     |  listen(...)
     |      listen([backlog])
     |      
     |      Enable a server to accept connections.  If backlog is specified, it must be
     |      at least 0 (if it is lower, it is set to 0); it specifies the number of
     |      unaccepted connections that the system will allow before refusing new
     |      connections. If not specified, a default reasonable value is chosen.
     |  
     |  recv(...)
     |      recv(buffersize[, flags]) -> data
     |      
     |      Receive up to buffersize bytes from the socket.  For the optional flags
     |      argument, see the Unix manual.  When no data is available, block until
     |      at least one byte is available or until the remote end is closed.  When
     |      the remote end is closed and all data is read, return the empty string.
     |  
     |  recv_into(...)
     |      recv_into(buffer, [nbytes[, flags]]) -> nbytes_read
     |      
     |      A version of recv() that stores its data into a buffer rather than creating 
     |      a new string.  Receive up to buffersize bytes from the socket.  If buffersize 
     |      is not specified (or 0), receive up to the size available in the given buffer.
     |      
     |      See recv() for documentation about the flags.
     |  
     |  recvfrom(...)
     |      recvfrom(buffersize[, flags]) -> (data, address info)
     |      
     |      Like recv(buffersize, flags) but also return the sender's address info.
     |  
     |  recvfrom_into(...)
     |      recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)
     |      
     |      Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.
     |  
     |  send(...)
     |      send(data[, flags]) -> count
     |      
     |      Send a data string to the socket.  For the optional flags
     |      argument, see the Unix manual.  Return the number of bytes
     |      sent; this may be less than len(data) if the network is busy.
     |  
     |  sendall(...)
     |      sendall(data[, flags])
     |      
     |      Send a data string to the socket.  For the optional flags
     |      argument, see the Unix manual.  This calls send() repeatedly
     |      until all data is sent.  If an error occurs, it's impossible
     |      to tell how much data has been sent.
     |  
     |  sendto(...)
     |      sendto(data[, flags], address) -> count
     |      
     |      Like send(data, flags) but allows specifying the destination address.
     |      For IP sockets, the address is a pair (hostaddr, port).
     |  
     |  setblocking(...)
     |      setblocking(flag)
     |      
     |      Set the socket to blocking (flag is true) or non-blocking (false).
     |      setblocking(True) is equivalent to settimeout(None);
     |      setblocking(False) is equivalent to settimeout(0.0).
     |  
     |  setsockopt(...)
     |      setsockopt(level, option, value: int)
     |      setsockopt(level, option, value: buffer)
     |      setsockopt(level, option, None, optlen: int)
     |      
     |      Set a socket option.  See the Unix manual for level and option.
     |      The value argument can either be an integer, a string buffer, or 
     |      None, optlen.
     |  
     |  settimeout(...)
     |      settimeout(timeout)
     |      
     |      Set a timeout on socket operations.  'timeout' can be a float,
     |      giving in seconds, or None.  Setting a timeout of None disables
     |      the timeout feature and is equivalent to setblocking(1).
     |      Setting a timeout of zero is the same as setblocking(0).
     |  
     |  share(...)
     |      share(process_id) -> bytes
     |      
     |      Share the socket with another process.  The target process id
     |      must be provided and the resulting bytes object passed to the target
     |      process.  There the shared socket can be instantiated by calling
     |      socket.fromshare().
     |  
     |  shutdown(...)
     |      shutdown(flag)
     |      
     |      Shut down the reading side of the socket (flag == SHUT_RD), the writing side
     |      of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  family
     |      the socket family
     |  
     |  proto
     |      the socket protocol
     |  
     |  timeout
     |      the socket timeout
     |  
     |  type
     |      the socket type

FUNCTIONS
    close(...)
        close(integer) -> None
        
        Close an integer socket file descriptor.  This is like os.close(), but for
        sockets; on some platforms os.close() won't work for socket file descriptors.
    
    dup(...)
        dup(integer) -> integer
        
        Duplicate an integer socket file descriptor.  This is like os.dup(), but for
        sockets; on some platforms os.dup() won't work for socket file descriptors.
    
    getaddrinfo(...)
        getaddrinfo(host, port [, family, type, proto, flags])
            -> list of (family, type, proto, canonname, sockaddr)
        
        Resolve host and port into addrinfo struct.
    
    getdefaulttimeout(...)
        getdefaulttimeout() -> timeout
        
        Returns the default timeout in seconds (float) for new socket objects.
        A value of None indicates that new socket objects have no timeout.
        When the socket module is first imported, the default is None.
    
    gethostbyaddr(...)
        gethostbyaddr(host) -> (name, aliaslist, addresslist)
        
        Return the true host name, a list of aliases, and a list of IP addresses,
        for a host.  The host argument is a string giving a host name or IP number.
    
    gethostbyname(...)
        gethostbyname(host) -> address
        
        Return the IP address (a string of the form '255.255.255.255') for a host.
    
    gethostbyname_ex(...)
        gethostbyname_ex(host) -> (name, aliaslist, addresslist)
        
        Return the true host name, a list of aliases, and a list of IP addresses,
        for a host.  The host argument is a string giving a host name or IP number.
    
    gethostname(...)
        gethostname() -> string
        
        Return the current host name.
    
    getnameinfo(...)
        getnameinfo(sockaddr, flags) --> (host, port)
        
        Get host and port for a sockaddr.
    
    getprotobyname(...)
        getprotobyname(name) -> integer
        
        Return the protocol number for the named protocol.  (Rarely used.)
    
    getservbyname(...)
        getservbyname(servicename[, protocolname]) -> integer
        
        Return a port number from a service name and protocol name.
        The optional protocol name, if given, should be 'tcp' or 'udp',
        otherwise any protocol will match.
    
    getservbyport(...)
        getservbyport(port[, protocolname]) -> string
        
        Return the service name from a port number and protocol name.
        The optional protocol name, if given, should be 'tcp' or 'udp',
        otherwise any protocol will match.
    
    htonl(...)
        htonl(integer) -> integer
        
        Convert a 32-bit integer from host to network byte order.
    
    htons(...)
        htons(integer) -> integer
        
        Convert a 16-bit unsigned integer from host to network byte order.
        Note that in case the received integer does not fit in 16-bit unsigned
        integer, but does fit in a positive C int, it is silently truncated to
        16-bit unsigned integer.
        However, this silent truncation feature is deprecated, and will raise an 
        exception in future versions of Python.
    
    inet_aton(...)
        inet_aton(string) -> bytes giving packed 32-bit IP representation
        
        Convert an IP address in string format (123.45.67.89) to the 32-bit packed
        binary format used in low-level network functions.
    
    inet_ntoa(...)
        inet_ntoa(packed_ip) -> ip_address_string
        
        Convert an IP address from 32-bit packed binary format to string format
    
    inet_ntop(...)
        inet_ntop(af, packed_ip) -> string formatted IP address
        
        Convert a packed IP address of the given family to string format.
    
    inet_pton(...)
        inet_pton(af, ip) -> packed IP address string
        
        Convert an IP address from string format to a packed string suitable
        for use with low-level network functions.
    
    ntohl(...)
        ntohl(integer) -> integer
        
        Convert a 32-bit integer from network to host byte order.
    
    ntohs(...)
        ntohs(integer) -> integer
        
        Convert a 16-bit unsigned integer from network to host byte order.
        Note that in case the received integer does not fit in 16-bit unsigned
        integer, but does fit in a positive C int, it is silently truncated to
        16-bit unsigned integer.
        However, this silent truncation feature is deprecated, and will raise an 
        exception in future versions of Python.
    
    setdefaulttimeout(...)
        setdefaulttimeout(timeout)
        
        Set the default timeout in seconds (float) for new socket objects.
        A value of None indicates that new socket objects have no timeout.
        When the socket module is first imported, the default is None.

DATA
    AF_APPLETALK = 16
    AF_DECnet = 12
    AF_INET = 2
    AF_INET6 = 23
    AF_IPX = 6
    AF_IRDA = 26
    AF_SNA = 11
    AF_UNSPEC = 0
    AI_ADDRCONFIG = 1024
    AI_ALL = 256
    AI_CANONNAME = 2
    AI_NUMERICHOST = 4
    AI_NUMERICSERV = 8
    AI_PASSIVE = 1
    AI_V4MAPPED = 2048
    CAPI = <capsule object "_socket.CAPI">
    EAI_AGAIN = 11002
    EAI_BADFLAGS = 10022
    EAI_FAIL = 11003
    EAI_FAMILY = 10047
    EAI_MEMORY = 8
    EAI_NODATA = 11001
    EAI_NONAME = 11001
    EAI_SERVICE = 10109
    EAI_SOCKTYPE = 10044
    INADDR_ALLHOSTS_GROUP = -536870911
    INADDR_ANY = 0
    INADDR_BROADCAST = -1
    INADDR_LOOPBACK = 2130706433
    INADDR_MAX_LOCAL_GROUP = -536870657
    INADDR_NONE = -1
    INADDR_UNSPEC_GROUP = -536870912
    IPPORT_RESERVED = 1024
    IPPORT_USERRESERVED = 5000
    IPPROTO_ICMP = 1
    IPPROTO_IP = 0
    IPPROTO_RAW = 255
    IPPROTO_TCP = 6
    IPPROTO_UDP = 17
    IPV6_CHECKSUM = 26
    IPV6_DONTFRAG = 14
    IPV6_HOPLIMIT = 21
    IPV6_HOPOPTS = 1
    IPV6_JOIN_GROUP = 12
    IPV6_LEAVE_GROUP = 13
    IPV6_MULTICAST_HOPS = 10
    IPV6_MULTICAST_IF = 9
    IPV6_MULTICAST_LOOP = 11
    IPV6_PKTINFO = 19
    IPV6_RECVRTHDR = 38
    IPV6_RECVTCLASS = 40
    IPV6_RTHDR = 32
    IPV6_TCLASS = 39
    IPV6_UNICAST_HOPS = 4
    IPV6_V6ONLY = 27
    IP_ADD_MEMBERSHIP = 12
    IP_DROP_MEMBERSHIP = 13
    IP_HDRINCL = 2
    IP_MULTICAST_IF = 9
    IP_MULTICAST_LOOP = 11
    IP_MULTICAST_TTL = 10
    IP_OPTIONS = 1
    IP_RECVDSTADDR = 25
    IP_TOS = 3
    IP_TTL = 4
    MSG_BCAST = 1024
    MSG_CTRUNC = 512
    MSG_DONTROUTE = 4
    MSG_ERRQUEUE = 4096
    MSG_MCAST = 2048
    MSG_OOB = 1
    MSG_PEEK = 2
    MSG_TRUNC = 256
    MSG_WAITALL = 8
    NI_DGRAM = 16
    NI_MAXHOST = 1025
    NI_MAXSERV = 32
    NI_NAMEREQD = 4
    NI_NOFQDN = 1
    NI_NUMERICHOST = 2
    NI_NUMERICSERV = 8
    RCVALL_MAX = 3
    RCVALL_OFF = 0
    RCVALL_ON = 1
    RCVALL_SOCKETLEVELONLY = 2
    SHUT_RD = 0
    SHUT_RDWR = 2
    SHUT_WR = 1
    SIO_KEEPALIVE_VALS = 2550136836
    SIO_LOOPBACK_FAST_PATH = 2550136848
    SIO_RCVALL = 2550136833
    SOCK_DGRAM = 2
    SOCK_RAW = 3
    SOCK_RDM = 4
    SOCK_SEQPACKET = 5
    SOCK_STREAM = 1
    SOL_IP = 0
    SOL_SOCKET = 65535
    SOL_TCP = 6
    SOL_UDP = 17
    SOMAXCONN = 2147483647
    SO_ACCEPTCONN = 2
    SO_BROADCAST = 32
    SO_DEBUG = 1
    SO_DONTROUTE = 16
    SO_ERROR = 4103
    SO_EXCLUSIVEADDRUSE = -5
    SO_KEEPALIVE = 8
    SO_LINGER = 128
    SO_OOBINLINE = 256
    SO_RCVBUF = 4098
    SO_RCVLOWAT = 4100
    SO_RCVTIMEO = 4102
    SO_REUSEADDR = 4
    SO_SNDBUF = 4097
    SO_SNDLOWAT = 4099
    SO_SNDTIMEO = 4101
    SO_TYPE = 4104
    SO_USELOOPBACK = 64
    TCP_FASTOPEN = 15
    TCP_KEEPCNT = 16
    TCP_KEEPIDLE = 3
    TCP_KEEPINTVL = 17
    TCP_MAXSEG = 4
    TCP_NODELAY = 1
    has_ipv6 = True

FILE
    c:\program files\python37\dlls\_socket.pyd


